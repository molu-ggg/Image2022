# 	数据结构

 专业知识

Created At : 2021-03-12 00:00

Views 👀 :20

# 第二章 线性表

线性表：表内数据类型相同，有限序列

本章将以总结的形式展现：

## 2.1 顺序表与链式表的区别

|          | 顺序表                          | 链式表                             |
| :------- | :------------------------------ | :--------------------------------- |
| 存取     | 随机存取                        | 顺序存取                           |
| 结构     | 顺序存储（连续）                | 随机存储（不连续）                 |
| 空间分配 | 静态存储（可以动态分配）        | 动态存储                           |
| 操作     | **查找 O(1) ,插入和删除O（n）** | **查找 O(n) ,插入和删除O（1）**    |
| 缺点     | 插入删除不便，长度不可以改变    | 查找速度慢，占用空间大（存储指针） |

## 2.2 头指针与头结点,首元结点

头指针指向链表的第一个节点（不管是否含有头结点）

头结点：不存储信息或者存储特殊信息的结点，好处是：

① 便于基本操作，第一个有数据的结点与后面的处理方式一样，不用特殊处理

② 链表是否为空，头指针都指向头结点

首元结点：

第一个含有 数据元素的结点

## 2.3 顺序表的基本操作：

插入删除要考虑的：

是否越界（插入位置不合理） ，是否（空、满）

:100:

## 2.4 链表基本操作：

头插法与尾插法：

头插法：插入表头之后，插得越早越在后面

尾插法：链表顺序与插入的顺序一致

单链表与循环链表删除节点的操作

```c++
p-> next = Null//是否为空
p  =  getElem(L,i-1)// 寻找前继结点
q = p->next// 将待删除节点的值临时保存
p->next = p->next ->next// 删除
free(q)// 释放
```

注意：若循环链表删除的结点的后一个结点的操作 是一样的操作

双链表操作：

![img](D:\typora文件-图片\171951-630686.png)

插入：（有几种插入顺序）

```c++
s->next = p->next 
p->next ->prior = s
p->next = s 
s->prior = p
```

注意：插入方式不唯一，保证 1,2要在3之前完成

这样就有 ： 1,2,3,4,1,2,4,3；2,1,3,4；2,1,4,3；

 1,4,2,3；4,1,2,3；2,4,1,3；4,2,1,3；

:100: 答案有待验证

删除：

```c
p->next = q->next;
q->next ->prior = p ;
free(q);
```

:100: 代码实现：

2.5 静态链表

![img](https://github.com/molu-ggg/Image2022/blob/master/img/202108/07/105519-557024.png)

<img src="https://github.com/molu-ggg/Image2022/blob/master/img/202108/07/105519-557024.png" width = "600" height="60px" />



![img](https://s2.loli.net/2022/06/08/S73o2saxGh1gjp6.png)

```c++
struct node {
 int data ;
 int next ; //存储 地址
}
```

next 存储的是相对地址，分配的是连续的内存空间



## 2.5 性能比较

主要从空间与时间复杂度两个角度

是衡量一个算法好坏的必备 要素

## 2.6 其他小知识点

- :100:动态分配：不需要一次性为线性表一次性划分所有空间，**而是根据申请的最大空间，** 一旦数据结构空间占满，就会开辟一块更大的存储空间，用来替换原来的存储空间，从而达到扩充存储空间的目的 。并不是链式存储，而是随机存取方式

- 头插法与尾插法：头插法可以实现倒置

- 倒置的题目还有： 王道 p17:10  p 38: 5 p39 :22,25 

- 快慢指针 **p39 ： 24** 

  

# 第三章 栈与队列

## 3.1 栈与队列的区别

|          | 栈                                                           | 队列                                                         |
| :------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
|          | 先进后出                                                     | 先进先出                                                     |
|          |                                                              |                                                              |
| 遍历速度 | 栈只能从头部取数据，也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性。 | 队列则不同，它基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多 |
|          |                                                              |                                                              |

:100: https://zhidao.baidu.com/question/223432364.html 没太看懂

## 3.2 栈的知识点

- 卡特兰数：

  n个不同元素进栈，出战元素不同进栈顺序可以为：1/(n+1)Cn2n1/(n+1)C2nn

- 顺序栈：

  进栈操作：栈不满，栈顶指针先+1 再奖值送到栈顶元素里

  出栈操作：栈非空，取出栈顶元素，指针 -1 （这里的1指的是一个单位）

- 共享栈：

![image-20210219201351205](D:\typora文件-图片\171844-136893.png)

![在这里插入图片描述](20200418153945359.gif)

 栈空与栈满的判断条件：

 左： top0 =-1 右：top1 = Maxsize

 栈满： top1-top0 = 1

- **如何判断出栈顺序是否合理？ p70页自己总结：**

  相对位置靠前的，必定逆序，其他的没有要求

- 链式栈：

  入栈操作：（前插法）

  ```c++
  //假设指针top指向栈顶，p是表头，q新建空间
  q->next = top (p->next)
  p->next = q ;
  top--;
  ```

  出栈：

  ```c++、、
  if (s==NULL) return 0 ;//判断是否为空
  x = s->data;//保存
  p =s ; //保存
  s =s->next;//指针后移
  delete p ;//释放
  ```

  


## 3.3 队列的知识点

- front 队头，rear队尾   

- 假溢出：q.rear = MAXNSIZE当做队满条件，会存在还有可以存放元素位置的地方，解决办法：循环队列

  ![img](D:\typora文件-图片\203103-111988.jpeg)

- 循环队列

![img](D:\typora文件-图片\171839-101678.jpeg)

判断条件：初始时: q.front = q.rear = 0

队首指针进1 ： q.front =(q.front+1)%Maxsize

队尾指针出1 ：q.rear = (q.rear+1)%Maxsize

队列长度：（q.rear+Maxsize -q.front)%Maxsize

为了区分队满与队空的方法：

① 少使用一个空间：队满条件就是： （q.rear+1)%Maxsize ==q.front

② 增加 统计元素个数的成员Q.size ,队满条件就是： q.size == Maxsize

③ 增加tag成员 出队时tag=0 ， 入队时 tag =1

- 链式队列：具有队头指针与队尾指针的单链表
- 双端链表：了解

## 3.4 栈与队列的应用

队列

① 主机与外部设备不匹配问题：打印数据缓冲区

② 多用引起的资源竞争问题：CPU资源就绪队列等

③ 层次遍历

栈：

① 递归

② 遍历（后续遍历等）

# 第四章 串

## 4.1 串的存储方式

1.定长顺序存储：

地址连续的存储单元存储字符序列

串的长度只能小于等于MAXSIZE 否则 发生截断（截断后面的还是前面的？）

```c++
typedef struct 
 char ch[MAXNSIZE];
 int length ;
SString ;
```

2.堆分配存储表示：
地址连续的存储单元存储字符序列。存储空间是动态分配的

```c++
typedef struct 
char *ch;
int length;
SString ;
```

3.块链存储表示：

类似链式存储结构 ，有n个结点连起来 ，通常最后一个结点 占不满，用# 填充

![img](D:\typora文件-图片\200119-510473.png)

## 4.2 KMP算法

1.暴力匹配算法：

```c++
int  i =0 ,j = 0 ;
while(i<S.length()&&j<T.length())//S是主串
    if (S[i] == T[j]) i++,j++;
    else 
        i =  i- j +1 ;//暴力匹配算法的核心
        j =0 ;
        //若起始位置是 1,1 则 i = i-j+2 ;j =1 ;
    

if (j>=T.length()) return i-T.length();
```

2.kmp算法概括：

原理：

字符串中存在大量重复性的子串，暴力匹配造成大量的重复比较的动作，引入KMP，将对于当前匹配失败之前已经匹配成功 长度 为m的字符串 ，

**寻找小于 m的最长公共前后缀 ，将模式串指针前缀子串直接移动到 后缀子串的位置** 后比较，主串指针不动。

1 2 3 4 5 6 7 8 9

**A B** B **A B** C D C A

**A B** B **A B** A

在6处匹配失败，之前成功匹配的字符串L15中，将 1-2 直接移动到 4-5位置

为什么这样是有效的呢？ 

实际上，节约了匹配模式串前缀与主串的时间，前缀与后缀是一样的，将前缀移动到后缀对应主串的位置，这样就不用再比较前缀与主串了，next数组就为了求小于m的最长公共前后缀。

如何判断移动到哪去呢？

利用 next数组：子串的第j个字符与主串匹配失败，子串整体**左移**使第j个字符与 next[j] 位置 对应

注： next[j]的数值含义是：[0:**j-1**]最长公共前后缀。

小牛试刀：

王道p112 (5,6)

求 ‘ababaababaa' 的next数组，

答案是： -1 0 0 1 2 3 1 1 2 3 4 5 

或者是： 0  1 1 2 3 4 2 2 3 4 5 6

这样kmp主程序如下：

与暴力匹配算法只有两个地方不一样

```c++
int KMP(String S ,String T,int next[])
    int i =1 , j =1 ;
    while(i<S.length()&&j<T.length())
        if(S[i]==T[j]||j==0) i++,j++;
        else j=next[j];
    
    if(j>T.length()) return i-T.length();
    else return 0 ;

```

3.next数组

手算求解办法：https://blog.csdn.net/m0_37482190/article/details/86667059

这里将起始位置视为 1 而不是 0 

j可以实际意味着确定公共前后缀的长度

```c++
void get_next(String T ,int next[])
   int i=1 ,j =0 ;
   while(i<T.length())
    //若 p i==pj ,则 next[j+1] = next[j]+1 没看懂 
       if (j==0||T[i]==T[j]) i++,j++,next[i]= j ;
       else j = next[j];
   

```

4.nextval数组：

解决类似出现 连续字符，next数组依然需要挨个比较 的问题

该位置i与next[i]元素比较，不同为next[i]值

相同则递归 比较 next[i]与 next[next[i]] 的值，直到不同或者nextval[k] = 0

```c++
void get_next(String T ,int next[])
   int i=1 ,j =0 ;
   while(i<T.length())
    i++,j++;
       if (j==0||T[i]==T[j]) nextval[i]= j ;
       else nextval[i]= nextval[j];
   
    else j = nextval[j];

```

# 第五章 树

关键词：树 二叉树 遍历二叉树 线索二叉树 排序二叉树 平衡二叉树 树的存储 森林 森林树与二叉树的转换 并查集 哈夫曼树

## 5.1 树：

1.定义：

n= 0 为空树

n>=1 有且只有一个根节点,且其余节点为互不相交的有限集合，且每一个集合本身又是一棵树

2.树的高度与深度区别：深度是从根节点向下，高度是从叶节点向上。

3.树的基本性质：（对照 二叉树的性质）

① 节点数 = 所以叶子节点的度数 +1

② 度数 为m的数在第 i层 至多有 mi−1mi−1

③ 高度 为h 的 m叉树至多 有(mh−1)(m−1)(mh−1)(m−1)个结点

## 5.2 二叉树

1.定义：

n=0,空二叉树

n>=1 ,有且只有一个根节点和两个互不相交的集合，分别为左子树和右子树

2.与度数为2的区别：

二叉树可以为空树，度数为2的树得至少3个结点

度数为2的树无严格的左右之分，比如只有一个孩子的树，二叉树必须确定是左孩子还是右孩子

3.满二叉树与完全二叉树

4.二叉树性质：

① 节点数 = 所以叶子节点的度数 +1

② 在第 i层 至多有 2i−12i−1

③ 高度 为h 的 2叉树至多 有(2h−1)(2h−1)个结点

④具有n个结点的完全二叉树 深度为 Llog2nJ+1Llog2nJ+1

5.二叉树的存储结构：

①顺序存储：自上而下，从左到右，适合完全二叉树与满二叉树

②二叉链表

③ 三叉链表（线索链表）

6.二叉树的应用：

采用了二分的思想，遍历、搜索、平衡二叉树，公式计算采用了后序遍历二叉树

## 5.3 遍历二叉树，线索二叉树

### 5.3.1 遍历二叉树

1.遍历的本质:将二叉树线性化的过程 ，转化成线性序列

2.先序中序后序遍历：根 左 右 左 根 右 左 右 根

:100: 代码的实现：

有递归与非递归两种算法,非递归实现的思路:

中序: 左中右

前序：中左右

后序：左右中

![img](mindmaster_image/113954-515448.png)

先序遍历建立二叉链表，计算二叉树深度，复制二叉树,统计结点个数：

后序遍历代码实现：p148 9

```
//p是结点S是栈
while(){
   
   if (p){
      S.push(p);
      p = p->lchild;
   }
   else {
      if(p->rchild &&  p->rchild != r){
         p = p->rchild ;
      }
      else {
          visit(p);
          r = S.pop();
          p = NULL ; 
      }
   }
}
```

3.由遍历序列 构造二叉树：

先序遍历和中序遍历 可以唯一确定一棵二叉树

后序遍历和中序遍历 也可以唯一确定二叉树

原因是什么？ 对于每一棵树可以确定根节点，以及左子树与右子树，这样递归确定最终的二叉树



### 5.3.2 线索二叉树

实质：将二叉链表的空指针指向前驱或者后驱

结点的格式：

| lchild     | LTag                     | data     | RTag                     | rchild     |
| :--------- | :----------------------- | :------- | :----------------------- | :--------- |
| 左孩子指针 | 是（1）否（0）左孩子为空 | 节点数据 | 是（1）否（0）右孩子为空 | 右孩子指针 |

![image-20210811113950037](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811113950037.png)

包括三种，前序中序后序线索化树

:100: 代码实现：p136

```c++
void InTread ( &p , &pre)

 if(p!=NULL)
    InTread(p->lchild,pre);
    if(p->lchild == NULL){
        p->lchild == pre ;
        p->ltag = 1 ;       
    }
 
  if(pre != NULL && pre->rchild ==NULL){
       //右指针的赋值是在下一个指针 时线索化，此时 该节点为pre
        pre -> rchild = p;
        pre -> rtag = 1 ;
            
    }
     pre = p ;   
     InTread(p->rchild,pre);


```

## 5.4 排序二叉树 与平衡二叉树

二叉排序树不是平衡二叉树，它的值满足： 左子树> 根>右子树

难点在于：二叉树的删除

有以下三种情况，最值得注意的是最后一种：

![image-20210811104935167](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811104935167.png)

平衡二叉树：

是基于二叉排序树，删除操作与二叉排序树基本一样，不一样在最后一种情况，调整策略是看左右子树谁更高就用哪边的树来填补

平衡二叉树的插入：

```c++

 
// 定义平衡二叉树的结点结构
typedef struct BiTNode
{
    int data;
    int bf;             // 平衡因子
    BiTNode *lchild, *rchild;
}BiTNode, *BiTree;

```

① LL调整：

![image-20210811105804226](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811105804226.png)

A是* p ,B 是L，则用代码表示为：

```c++
void R_Rotate( BiTree *p )
{
    BiTree L;
    L = (*p)->lchild;
    (*p)->lchild = L->rchild;
    L->rchild = *p;
    *p = L;
}
```

② RR调整：

![image-20210811110421341](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811110421341.png)

```c++
// 左旋处理，即RR调整
void L_Rotate( BiTree *p )
{
    BiTree R;
    R = (*p)->rchild;
    (*p)->rchild = R->lchild;
    R->lchild = *p;
    *p = R;
}
```



③ LR 调整：

![image-20210811110515546](mindmaster_image/image-20210811110515546.png)

说出这种调整过程：根据情况进行判断，将LR拆成LL，RR两个技术动作。先对左子树RR调整，后对T LL调整，调整过程如下：

![img](https://github.com/molu-ggg/Image2022/blob/master/img/AB26A0A6260D72899233A9B7E8A5C312.png)

```
// 左平衡旋转处理，包括 LL 和 LR 调整
void LeftBalance( BiTree *T )
{
    BiTree L, Lr;
    L = (*T)->lchild;
    switch( L->bf )
    {
    case 1:        // 新结点插入在T的左孩子的左子树上，为LL型，作右旋处理即LL调整
        (*T)->bf = L->bf = 0;
        R_Rotate( T );
        break;
    case -1:        // 新结点插入在T的左孩子的右子树上，为LR型，作双旋处理
        Lr = L->rchild;
        switch( Lr->bf )
        {
        case 1:
            (*T)->bf = -1;
            L->bf = 0;
            break;
        case 0:
            (*T)->bf = L->bf = 0;
            break;
        case -1:
            (*T)->bf = 0;
            L->bf = 1;
            break;
        }
        Lr->bf = 0;
        L_Rotate( &(*T)->lchild );      // 先对T的左子树进行左旋处理即RR调整
        R_Rotate( T );                  // 再对T进行右旋处理即LL调整
    }
}


```

④ RL调整：

对T的右子树进行RR调整，后对T LL调整

![image-20210811112025017](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811112025017.png)

```
// 右平衡旋转处理，包括 RR 和 RL 调整
void RightBalance( BiTree *T )
{
    BiTree R, Rl;
    R = (*T)->rchild;
    switch( R->bf )
    {
    case -1:        // 新结点插入在T的右孩子的右子树上，为RR型，作左旋处理即RR调整
        (*T)->bf = R->bf = 0;
        L_Rotate( T );
        break;
    case 1:        // 新结点插入在T的右孩子的左子树上，为RL型，作双旋处理
        Rl = R->lchild;
        switch( Rl->bf )
        {
        case 1:
            (*T)->bf = 0;
            R->bf = -1;
            break;
        case 0:
            (*T)->bf = R->bf = 0;
            break;
        case -1:
            (*T)->bf = 1;
            R->bf = 0;
            break;
        }
        Rl->bf = 0;
        R_Rotate( &(*T)->rchild );      // 先对T的左子树进行左旋即RR调整
        L_Rotate( T );                  // 再对T进行右旋即LL调整
    }

}
```

删除的办法

## 5.5 树森林

## 5.6 树的存储

双亲表示法：给每一个结点标号，然后将孩子指向双亲

说明：需要连续的存储空间，能确定唯一的双亲，但确定孩子需要遍历整棵树

孩子表示法：给每一个结点标号，然后将孩子结点用单链表连接起来

说明：寻找子女很方便，但是双亲就很麻烦

孩子兄弟表示法：又称为二叉树表示法

每个节点包括：节点值，指向第一个节点的指针，指向下一个兄弟结点的指针

## 5.7 树的应用

5.7.1 哈夫曼树

5.7.2 并查集

## 5.8 红黑树

![img](https://github.com/molu-ggg/Image2022/blob/master/img/251730074203156.jpg)

红黑树的特性:
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

红黑树的应用比较广泛，主要是用它来存储有序的数据

# 第六章 图

极大连通子图：连通图本身

连通分量：无向图的极大连通子图

极小连通子图：最小生成树

## 6.1 存储结构

在哪几个方面可以比较：空间复杂度，基本操作（查找邻边 ，删除顶点）

|              | 说明                                                         | 空间复杂度                  | 找相临边           | 删除边与顶点       |
| :----------- | :----------------------------------------------------------- | :-------------------------- | :----------------- | :----------------- |
| 邻接矩阵     | 适合于稠密矩阵，能反应各顶点之间的连接关系                   | O( n2n2)                    | 方便 o(V)          | 边方便，顶点不方便 |
| 邻接表       | （边表和顶点表） 结合顺式存储与链式存储方法，适用于稀疏图，减少空间的浪费 | 有向图 O(V+E);无向图O(V+2E) | 需要遍历整个邻接表 | 都不方便           |
| 十字链表     | **有向图**的链式存储结构                                     | O(V+E)                      | 方便               | 方便               |
| 邻接多重表： | 无向图的一种链式存储结构                                     | O(V+E)                      | 方便               | 方便               |

邻接矩阵：适合于稠密矩阵，能反应各顶点之间的连接关系

 空间复杂度O( n2n2),寻找邻边不方便 ，

邻接表： 某一个点出度指向的点依次相连形成链式结构

 计算某两个点是否相连不能直接得出，**出度**计算方便，计算**入度**得用逆邻接表

**十字链表**： **有向图**的链式存储结构

![image-20210130163046685](https://github.com/molu-ggg/Image2022/blob/master/img/202108/11/115331-664239.jpeg)

firstin 指向该定点作为**弧头** 的第一条弧

firstout 指向该定点作为**弧尾** 的第一条弧

:100: **如何实现呢？**

邻接多重表：无向图的一种链式存储结构

![image-20210130163831331](mindmaster_image/153248-836462.png)

:100: **如何实现呢？**（理解代码就行）

进行边，点的删除操作 09:00

## 6.2 图的遍历

DFS 与BFS ：

空间复杂度：O(|V|)

时间复杂度：采用邻接矩阵是O(|V|2|V|2 )，采用邻接表示O(|V|+|E|)

## 6.3 图的应用

### 6.3.1 最小生成树

**1.特点：**

包含图中所有顶点，且含有尽可能少的边

边数= 顶点数-1

最小生成树不唯一，权值之和唯一

**2.求解算法：**

prim 与 kruskal

简述两种算法的原理，思想，步骤，代码的实现：

原理:贪心算法

思想：

从某一个顶点开始，循环执行：选择当前**与已选择的顶点集合**相连的没有加入树的**权值最小**的顶点加入树，这样顶点全部在已选择的顶点集合停止

一句话：**每一次选择一个与当前T集合距离最近的顶点**

kruskal :

将边的权值排序，选择当前最短边加入树，并满足加入该边不成环 这样一直到 树里含有n-1条边为止

:100: 代码实现：

**3.应用：**

城市道路的修建，再怎么修路使得几个城市能相互到达且修路费用最低

（使得结点相互连通且loss最小）

### 6.3.2 最短路径

**1.两点之间的最短距离以及路径**

**2.求解算法：**

Dijkstra 与 Floyd 算法原理，思想，步骤，代码的实现：

Dijkstra算法：

**本质归为贪心算法**

初始化操作： vis path dis三个数组，分别记录顶点是否被访问，路径 以及 当前到该顶点的最短距离。初始化 vis 为未访问，初始化dis为 v0到所有顶点的长度，不相连置正无穷

循环执行n-1次：

从一顶点v1出发，找出与该顶点相连的顶点 ，更新当前从v0经过v1到每个顶点的最短路径，选择最短路的顶点作为一条路径点，vis置已访问

```c++

for( i=l; i<n;++i) II对其余 n-1个顶点，依次进行计算
min= Maxlnt;
for(w= O;w<n;++w)
```

==Floyd== ：

**是一种动态规划**

任意两点之间的最短距离

![image-20210201103419712](mindmaster_image/153259-101399.png)

初始化 A为两点之间的有向距离，path 是 i —> j 经过什么点 当前的路径最短

循环判断 n-1次：

 每次 对于i!=j,i!=v,j!=v 的边 进行判断： i经过v点到达j比之前 是否更短

 即 A[i][j]>A[i][v]+A[v][j]A[i][j]>A[i][v]+A[v][j]

证明：

假设Ak(i,j)Ak(i,j)表示不经过比k大的中间结点的i,j,之间的最短路径

首先，为了实现这个假设 ，采用一个递推式 ：

Ak(i,j)Ak(i,j) 要么 继承Ak−1(i,j)Ak−1(i,j) 要么是 Ak−1(i,k)+Ak−1(k,j)Ak−1(i,k)+Ak−1(k,j) 比前者更优秀

也就是 Ak(i,j)=min(Ak−1(i,j),Ak−1(i,k)+Ak−1(k,j))Ak(i,j)=min(Ak−1(i,j),Ak−1(i,k)+Ak−1(k,j))

这句话说明，对于 An(i,j)<=Ak(i,j)An(i,j)<=Ak(i,j)

> **Dijkstra 与 prim的比较：**
>
> Dijkstra算法用于构建**[单源点的最短路径树](https://en.wikipedia.org/wiki/Shortest-path_tree)**(MST),Prim算法用于构建**[最小生成树](https://en.wikipedia.org/wiki/Minimum_spanning_tree)**

### 6.3.4 拓扑排序

1.特点：

有向无环图，结点出现只能一次

> AOV网络：表示结点活动的网络，用来表示结点发生的先后顺序

2.步骤：

每一次选择 入度为0 的结点放入栈中 ，

出栈 ， 放到拓扑队列中，并将 该点与之指向的结点的入度-1 ，并将每一次选择 入度为0 的结点放入栈中 。

这样循环 n次即可

> 逆拓扑排序了解一下

:100:拓扑排序的代码实现：

**3.应用：**

**判断是否有回路：dfs 与拓扑排序**

求解关键路径

[语音识别中的应用](https://www.zhihu.com/question/39748146)：

[tensorflow数据流图](https://blog.csdn.net/wangrongrongwq/article/details/114376673)

![img](mindmaster_image/113055-306258.jpeg)

### 6.3.4 关键路径

1.特点：

与结点之前连接的所有活动做完才可以进行该节点以及以后的活动（也是拓扑排序的特点）

AOE网络，与AOV网络区别：

> 顶点表示事件，有向边表示活动的网络AOE

2.求解算法：

拓扑排序

对于事件，也就是结点，

最早发生时间：按照拓扑排序 以此 **max**

最晚发生时间：按照逆拓扑排序 ，依次 **min**

**最早与最晚发生时间一样的是关键事件**

对于活动，也就是过程ak i—->j 为

最早发生时间： vi最早发生时间

最晚发生时间： vj最晚发生时间 - ak 权值

时间余量 ： 活动最晚−最早发生时间活动最晚−最早发生时间

**时间余量为0 就是关键活动，也就是 最早与最晚时间一样的**

3.应用：

评估一个项目完成最短时间，求出能够影响整个工程的关键路径

### 6.3.5 有向无向图描述表达式

# 第七章 查找

## 7.1 顺序与折半查找

## 7.2 分块查找

![image-20210202102438958](mindmaster_image/151817-474283.png)

1.基本思想：

将查找表分成若干个子块，块内无序，块间有序（第一个块的最大关键字小于第二个块的最小关键字）

2.查找方法：

可以结合顺序与折半查找的方法，进行两层查找。如歌折半查找 30

**首先折半查找 关键字 ， 然后折半查找 块内元素**

3.平均找找长度 ：

ASL=L关键字长度+L块内元素长度ASL=L关键字长度+L块内元素长度

L表示查利用某种方法的平均查找长度 ：

比如顺序，关键字有 5 个 ，则 L关键字长度=(1+2…+5)/5L关键字长度=(1+2…+5)/5

## 7.3 B树（多路平衡查找树）

定义：

1）树中的每个结点最多含有m个子树；

2）除了根结点和叶子结点，其他结点至少有[ceil(m / 2)（代表是取上限的函数）]个孩子；

3）若根结点不是叶子结点时，则至少有两个孩子（除了没有孩子的根结点）

4）所有的叶子结点都出现在同一层中，叶子结点不包含任何关键字信息；

所有结点的孩子的个数的最大值就是B树的阶

![image-20210202103949411](mindmaster_image/103950-168345.png)

查找描述：（自己总结的）

从 B树的根节点出发，在结点的有序表中进行查找，执行如下操作：

①若 Ki 关键字小于 该查询值 ， 继续查找

②ki等于 该值 ，查找成功；

③ki大于该值 ， 查找 ki左边指针指向的子树 结点并继续查找

④若遍历到结点最后一个关键字 ，查找 ki右边指针指向的子树 结点并继续查找

这样若一直查找到叶节点时，继续查找到失败结点则**查找失败**

:100: **B树的插入与删除？**

对于插入：

一个重要的操作就是分裂，怎么分裂：

① 插入后节点关键词少于m，直接插入，否则需要分裂：

② 否则分为两部分，左边放在源节点，右半部分新节点内，中间 [ceil(m / 2)（代表是取上限的函数）] 放入父亲节点，若父节点超过m，则重复② 操作指导根节点

![image-20210811123051244](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811123051244.png)

对于删除，三种情况：

① 可以直接删除：删除所在节点**关键词**个数大于等于[ceil(m / 2)] 

② 兄弟够借：关键词不够，去找相邻够的兄弟借，是需要双亲调整达到平衡

③ 兄弟不够借用，与双亲结点合并：

![image-20210811123106838](https://github.com/molu-ggg/Image2022/blob/master/img/image-20210811123106838.png)

如何保证 查找效率

做一个人为规定 ：

① 对于m叉查找树 ， 任何结点 至少含有 m/2 个分叉 ，（向上取整） ，即 m/2 -1 个关键字

② 比平衡树更严格 ， 任何一个结点 所有子树的高度必须相同

![image-20210202105244359](https://github.com/molu-ggg/Image2022/blob/master/img/105245-140913.png)

B树种大部分操作所需要的磁盘存取次数与B树的高度成正比

在B树上找节点是在磁盘中进行的，在节点内找关键词是在内存中进行的





## 7.4 B+ 树

![image-20210202115128774](mindmaster_image/153313-134836.png)

与B树的区别：

|                    | B                                                            | B+                                                           |
| :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 关键字与分支       | n关键字对应n+1分支                                           | n关键字对应n分支                                             |
| 关键字数量         | 叶子结点不包含关键字，不重复                                 | 叶子结点包含全部关键字                                       |
| 结点的作用         | B树的任何结点都包含了关键字以及记录的存储地址（也是有记录的） | 非叶子结点的作用是索引作用，只有最大关键字以及指向子树的指针，没有关键字的存储地址 |
| 关键字个数取值范围 | m/2 -1 < n< m-1(m/2 向上取整)                                | m/2 < n< m(m/2 向上取整)                                     |

:100: 查找与磁盘块 读取的操作的关系？

文件管理

## 7.5 散列表：

通常的散列函数有哪几种？

处理冲突的方式有哪几种？

失败与成功查找分母不一样，成功与失败查找率要明确

[史上超全排序大全总结:](https://blog.csdn.net/qq_44714448/article/details/119571076?spm=1001.2014.3001.5502)

① [直接插入排序](https://www.acwing.com/blog/content/8936/)

② [折半插入排序](https://www.acwing.com/blog/content/8943/)

③ [希尔排序](https://www.acwing.com/blog/content/8947/)

增量递减排序

④ [冒泡排序](https://www.acwing.com/blog/content/8948/)

⑤ [快速排序](https://www.acwing.com/blog/content/8949/)

如下图所示,假设最开始的基准数据为数组第一个元素23,则首先用一个临时变量去存储基准数据,即tmp=23;然后分别从数组的两端扫描数组，设两个指示标志:low指向起始位置，high指向末尾.

![这里写图片描述](https://github.com/molu-ggg/Image2022/blob/master/img/20180910121224126)

   首先从后半部分开始，如果扫描到的值大于基准数据就让high减1,如果发现有元素比该基准数据的值小(如上图中18<=tmp)，就将high位置的值赋值给low位置 ,结果如下:

![这里写图片描述](https://github.com/molu-ggg/Image2022/blob/master/img/20180910121350322)

这样一直到low == high ,将基准元素放在该位置

然后分别以该位置为分界线分成两个子表递归进行如上操作。

重复上述操作

⑥ [归并排序](https://www.acwing.com/blog/content/8969/)

二分递归，一直递归到区间只有一个节点，回溯，两两区间合并。

⑦ [简单选择排序](https://www.acwing.com/blog/content/8953/)

每次选择最小的元素与数组前面的元素交换

⑧ [堆排序](https://www.acwing.com/blog/content/8969/)

大顶堆：父节点值总比孩子节点的值大。

初始化堆：以根节点开始，遇到根节点小于左右孩子节点的值，则需要将较大的值与父亲节点交换，一直到叶节点，这样反复调整直到一次遍历没有做出调整为止。

每一次取出根节点，并用最后一个叶节点补充到根节点，利用上述办法调整成大顶堆

直到树为空。

⑨ [计数排序](https://www.acwing.com/blog/content/8985/)

https://www.cnblogs.com/xiaochuan94/p/11198610.html

空间换时间吧



⑩ [桶排序](https://www.acwing.com/blog/content/8989/)

⑪ [基数排序](https://www.acwing.com/blog/content/9003/)

不基于比较的元素